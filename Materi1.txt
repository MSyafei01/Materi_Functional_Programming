Pengantar Functional Programming
JavaScript adalah bahasa pemrograman yang bersifat multiparadigma. 
Banyak paradigma pemrograman yang bisa Anda ikuti untuk menyelesaikan masalah menggunakan JavaScript.

Berkenalan dengan Functional Programming
Functional programming (selanjutnya disingkat menjadi FP) adalah paradigma pemrograman yang didasarkan pada fungsi matematika murni, yakni fungsi harus menghindari perubahan data sehingga selalu menghasilkan nilai sama ketika diberikan argumen sama.



------------------------------------------------------------------------
let value = 0;

function addWith(addingValue) {
  value += addingValue;
  console.log(`Current value is ${value}`);
  return value;
}

const result1 = addWith(1); // Output: Current value is 1
const result2 = addWith(1); // Output: Current value is 2
const result3 = addWith(1); // Output: Current value is 3

console.log(result1, result2, result3); // Output: 1, 2, 3
Output : Current value is 1
Current value is 2
Current value is 3
1 2 3
------------------------------------------------------------------------
Fungsi addWith dikategorikan sebagai impure karena sifat pure function tidak terpenuhi.


1. (X) Menghasilkan nilai yang sama setiap kali dipanggil dengan argumen yang sama.
Contoh kode di atas menunjukkan bahwa nilai yang dikembalikan oleh fungsi addWith yang diberikan argumen 1 
selalu berbeda. Hal ini dipengaruhi oleh keadaan variabel value yang selalu berubah setiap kali pemanggilan 
terjadi. Ups! Ada efek sampingnya juga di sini.

2. (X) Tidak memiliki efek samping yang dapat memengaruhi keadaan di luar fungsi tersebut.
Pemanggilan fungsi addWith memiliki efek samping. Selain mengubah variabel value, fungsi ini juga menulis 
sesuatu ke I/O melalui pemanggilan console.log. Efek samping ini membuat hasil dari pemanggilan fungsi tidak hanya bergantung pada argumen yang diberikan, tetapi juga keadaan di luar fungsi tersebut.


------------------------------------------------------------------------
function addWith(value, addingValue) {
  return value + addingValue;
}

const result1 = addWith(0, 1);
console.log(`result1 is ${result1}`); // Output: result1 is 1

const result2 = addWith(result1, 1);
console.log(`result2 is ${result2}`); // Output: result2 is 2

const result3 = addWith(result2, 1);
console.log(`result3 is ${result3}`); // Output: result3 is 3

console.log(result1, result2, result3); // Output: 1, 2, 3

Output : 
result1 is 1
result2 is 2
result3 is 3
1 2 3

------------------------------------------------------------------------
Sekarang fungsi addWith menjadi pure function karena seluruh sifatnya telah terpenuhi.

1. (✓) Menghasilkan nilai yang sama setiap kali dipanggil dengan argumen yang sama.
Saat ini, fungsi addWith menerima dua argumen, yaitu value dan addingValue. Selama kedua nilai argumen 
tersebut sama, addWith akan mengembalikan nilai yang sama, kapan pun dan saat kondisi apa pun. Ini karena 
fungsi addWith sudah tidak bergantung pada nilai di luar dari cakupannya.

2. (✓) Tidak memiliki efek samping yang dapat memengaruhi keadaan di luar fungsi tersebut.
Fungsi addWith sudah tidak mengubah nilai di luar cakupannya, tetapi ia menghasilkan nilai baru. 
Dengan dihapusnya kode console.log dari dalam fungsi, ia juga sudah tidak melakukan operasi I/O yang dapat 
menyebabkan efek samping.

Keuntungan menggunakan pure function termasuk kemampuan untuk mengoptimalkan kode melalui memoization, 
yakni hasil dari fungsi disimpan dan digunakan kembali jika input yang sama ditemukan.


Potensi Tersembunyi Sebuah Fungsi (High-Order Function)
Kita sudah memahami bahwa fungsi dalam JavaScript bersifat first-class citizen. 
Fungsi dapat diperlakukan sebagai expression yang dapat disimpan dalam sebuah variabel atau dikirim sebagai 
argumen fungsi lain. 


Umumnya, teknik HOF digunakan untuk berbagai hal berikut :

- Mengabstraksi fungsi aksi dari sebuah proses asynchronous (kita akan belajar asynchronous dalam modul 
selanjutnya) dalam bentuk callback.
- Membuat utility function, yaitu fungsi Array.map, Array.filter, Array.reduce, dan sebagainya.
- Menerapkan teknik matematika, seperti currying dan function composition.
--------------------------------------------------------------------------------------------
function apply(operation, ...args) {
  // kita bisa menambahkan kode lain sebelum operation dijalankan.
  
  return operation(...args)
}

function sum(a, b, c) {
  return a + b + c;
}

function discount(disc, value) {
  return value - ((disc / 100) * value);
}

const productPrice = apply(sum, 100, 100, 200);
const withDiscount = apply(discount, 25, productPrice);

console.log('Product price:', productPrice); // Output: Product price: 400
console.log('With discount 25%:', withDiscount); // Output: With discount 25%: 300

Output : 
Product price: 400
With discount 25%: 300
--------------------------------------------------------------------------------------------

implementasi memoization pure function juga dilakukan dengan teknik HOF. 
Caranya adalah fungsi memoize menerima fungsi pure function sebagai argumen dan menyimpan hasil dari 
pemanggilan pure function untuk digunakan ketika terjadi pemanggilan ulang dengan argumen yang sama.


--------------------------------------------------------------------------------------------
// menerima argumen sebuah fungsi
function memoize(fn) {
  const cache = new Map();

  // mengembalikan nilai berupa fungsi
  return function(...args) {
    const key = JSON.stringify(args);

    if (cache.has(key)) {
      return cache.get(key);
    }

    const result = fn(...args);
    cache.set(key, result);

    return result;
  };
}


function sumArray(arr) {
  if (arr.length === 0) return 0;
  return arr[0] + sumArray(arr.slice(1));
}


const memoizedSumArray = memoize(sumArray);
const largeArray = Array.from({ length: 5000 }, (_, i) => i + 1);

console.time('Memoized Sum First Call');
console.log('Total:', memoizedSumArray(largeArray));
console.timeEnd('Memoized Sum First Call');

console.time('Memoized Sum Second Call (Cached)');
console.log('Total:', memoizedSumArray(largeArray));
console.timeEnd('Memoized Sum Second Call (Cached)');

Output : 

Total: 12502500
Memoized Sum First Call: 139.654ms
Total: 12502500
Memoized Sum Second Call (Cached): 0.181ms
--------------------------------------------------------------------------------------------

Anda bisa jalankan kode di atas. Lihat perbedaan yang sangat signifikan dari waktu yang dibutuhkan untuk 
memanggil fungsi memoizedSumArray pertama kali dan kedua kalinya.

Hal lain yang umum dilakukan dengan HOF adalah membuat fungsi yang menerapkan teknik currying. 
Dengan teknik currying, sebuah fungsi biasanya tidak mengambil semua argumen secara langsung. 
Ia mengambil satu argumen dulu, lalu mengembalikan sebuah fungsi baru yang menerima argumen kedua, begitu 
seterusnya 


Berikut adalah contoh teknik currying pada fungsi adjectivfy dan multipleBy.
--------------------------------------------------------------------------------------------
function adjectivfy(adjective) {
  return function (noun) {
    return `${noun} ${adjective}.`;
  }
}

function multipleBy(x) {
  return function(y) {
    return x * y;
  }
}

const coolifier = adjectivfy('keren');
const funnifier = adjectivfy('seru');

const multipleByFive = multipleBy(5);

console.log(coolifier('Dicoding')); // Output: Dicoding keren.
console.log(funnifier('JavaScript')); // Output: JavaScript seru.
console.log(multipleByFive(7)); // Output: 35
console.log(multipleByFive(10)); // Output: 50
--------------------------------------------------------------------------------------------

HOF juga bisa digunakan untuk komposisi fungsi, yaitu kita menggabungkan beberapa fungsi kecil menjadi satu 
fungsi yang lebih kompleks. Berikut adalah contoh praktik dari komposisi fungsi.


--------------------------------------------------------------------------------------------
function addOne(x) {
  return x + 1;
}

function square(x) {
  return x * x;
}

function compose(f, g) {
  return (x) => {
    return f(g(x));
  }
}

const addOneAndSquare = compose(square, addOne);

console.log(addOneAndSquare(1)); // output: 4
--------------------------------------------------------------------------------------------

Alur eksekusinya:

Fungsi compose(f, g)

Mengembalikan fungsi baru (x) => f(g(x)).

Artinya: kita masukkan x, lalu pertama dijalankan g(x), hasilnya kemudian dimasukkan ke f(...).

Jadi urutannya: compose(f, g)(x) = f(g(x)).

Deklarasi const addOneAndSquare = compose(square, addOne);

Di sini f = square dan g = addOne.

Maka: addOneAndSquare(x) = square(addOne(x)).

Eksekusi addOneAndSquare(1)

Pertama: jalankan addOne(1) → hasilnya 1 + 1 = 2.

Kedua: jalankan square(2) → hasilnya 2 * 2 = 4.


contoh di atas menunjukkan bahwa compose adalah HOF yang menggabungkan dua fungsi menjadi satu 
fungsi baru yang menjalankan g terlebih dahulu dan kemudian f.

Fungsi Array.map menerima sebuah fungsi sebagai argumen yang digunakan untuk memproses setiap elemen array.
 Fungsi Array.map mengembalikan array baru yang hasilnya adalah nilai dari pemanggilan
  fungsi pada setiap elemen array asli.























